#!/bin/bash

# Deploy the containers for the tcp-angular service into the ECS cluster
# This script does NOT wait until the deployed containers (tcp-angular) are actually RUNNING
# Assumes credentials are already set up in the default aws profile;
# assumes name of cluster to deploy to is in SSM key "/dev/cluster-name"
# sets the default ecs-cli cluster to that cluster.

# Fail on any error; unset variables are errors; show commands before executing:
set -eux

# TODO: see if logging anything from this script would be helpful

# TODO: make sure we're in the correct (root) directory
date

echo "Running in $PWD"

docker --version
ecs-cli --version

# TODO: ls any other necessary files here, so the script fails early

# do we have an .env file?

aws_region=$(curl -s http://169.254.169.254/latest/meta-data/placement/availability-zone | sed "s/[a-z]$//")

cluster_name=$(aws ssm get-parameter --region $aws_region --name "/dev/cluster-name" --query "Parameter.Value" --out text)

# Try this to authenticate:  TODO: may be unneeded
aws ecr get-login --region $aws_region --no-include-email
$(aws ecr get-login --region $aws_region --no-include-email)

echo "Configuring the default ECS cluster for ecs-cli to $cluster_name in region $aws_region..."
ecs-cli configure --cluster $cluster_name --region $aws_region --default-launch-type EC2

# Find out what the external FQDN of the Application Load Balancer (ALB) is;
# change the domain line in ../src/environments/environment.prod.ts to
# use that instead of localhost; e.g.:
# const domain = 'tcp-testing-3-dev-cluster-alb-877192071.us-east-1.elb.amazonaws.com:8080'

alb=$(aws ssm get-parameter --region $aws_region --name "${cluster_name}_alb_endpoint" --query "Parameter.Value" --out text)
echo "ALB FQDN is $alb"

# relative to project root:
envfile=src/environments/environment.prod.ts
mv $envfile $envfile.orig
echo -e "// Generated by deploy-to-ecs $(date)\nconst domain = '$alb:8080'\n" > $envfile
# skip everything up to the first blank (or all-spaces) line and append it:
sed '0,/^ *$/d' $envfile.orig >> $envfile

echo "Original environment file:"
cat $envfile.orig

echo -e "\nModified environment file:"
cat $envfile

echo

echo "Building the Docker image...."
npm run docker:build

echo "Checking for the Docker image..."
docker image ls | grep tcp-angular

echo "Pushing excellaco/tcp-angular image to ECR..."
ecs-cli push --aws-profile default excellaco/tcp-angular:latest

cd tcp-angular-ecs

echo "Checking current state of service..."
(ecs-cli compose --aws-profile default service ps ||:) | tee service-status

# Remember: failed grep returns an error (1)

# States not in { RUNNING, STOPPED } include { PENDING }
state=OTHER

# If ANY are RUNNING, state is ACTIVE
if ( grep -q RUNNING service-status ) ; then
    state=ACTIVE
elif  ( grep -q STOPPED service-status ) ; then
    state=INACTIVE
elif  ( grep -q ServiceNotFoundException service-status ) ; then
    state=NONEXISTENT
fi

echo "state is $state"

if [ "$state" == "OTHER" ] ; then
    echo "ERROR: unknown service state; see above.  Quitting...."
    exit 2
fi

if [ "$state" == "ACTIVE" ] ; then
   echo "Bringing service down (because current state is $state)..."
   ecs-cli compose --aws-profile default service down
   sleep 5  # give it some time to drain
fi

# If the service was running before, it will take some time (< 60 seconds) to drain
echo "Bringing service up..."
counter_limit=10
counter=$counter_limit
until ( ecs-cli compose --aws-profile default service up ) ; do
    counter=$((counter - 1))
    if (( counter <= 0 )); then
        echo "ERROR: Could not bring service up after $counter_limit attempts.  Quitting..."
        date
        cd ..
        exit 3
    fi
    sleep 5
done;

echo "Checking state of service..."
ecs-cli compose --aws-profile default service ps

# TODO: wait around until at least two things are RUNNING

date
cd ..
