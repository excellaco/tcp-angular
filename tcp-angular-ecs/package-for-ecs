#!/bin/bash

# Create the Docker image for the service.
# Takes one argument: the image repo (with no label).
# All actions are local to the VM; does not use aws or ecs-cli.
# Should be run before configure-for-ecs and deploy-to-ecs are run.
# Assumes the environemnt variable GIT_COMMIT is set (typically by Jenkins).
# Assumes the directory for the service exists in this directory,
# its name matches "*-ecs", and it is the only directory that matches.

# Fail on any error; unset variables are errors; show commands before executing:
set -eux

IMAGE_REPO="$1"

GIT_COMMIT=${GIT_COMMIT:-unknown}
GIT_COMMIT=${GIT_COMMIT:0:7}

ECS_DIR=$(find . -maxdepth 1 -type d -name "*-ecs")

# Keep the docker-compose.yml file around and in its original state; use it if it already exists
if [ -f docker-compose.yml.ORIG ]; then
  echo "docker-compose.yml.ORIG is FOUND"
  mv docker-compose.yml.ORIG docker-compose.yml
fi
cp -p docker-compose.yml docker-compose.yml.ORIG

# TODO: see if logging anything from this script would be helpful

# TODO: make sure we're in the correct (root) directory
# Can just check for Dockerfile, and cd .. if not there

echo "=== package-for-ecs ==="
date

echo "Running in $PWD"
echo "IMAGE_REPO is $IMAGE_REPO"
if [[ "$IMAGE_REPO" = "" ]] ; then
    echo "ERROR: missing or empty image repository provided.  Quitting...."
    exit 2;
fi

docker --version

# relative to project root:
git checkout src/environments/environment.ts src/environments/environment.prod.ts
for envfile in src/environments/environment.ts src/environments/environment.prod.ts ; do
    echo "Working on $envfile" # Debug
    # always start from $envfile.orig if it's there:
    if [[ -f $envfile.orig ]]; then mv $envfile.orig $envfile ; fi
    mv $envfile $envfile.orig
    # The const domain setting can span multiple lines, so we have to do this song and dance:
    touch $envfile
    echo -e "// Generated by package-for-ecs $(date)\n" >> $envfile
    # Replace everything between the BEGIN and END lines (inclusive) with const domain=...:
    # (The first "c" in "cconst" is a sed command, not part of the inserted text.)
    #sed -e "/BEGIN DOMAIN DEF/,/END DOMAIN DEF/cconst domain = '$alb:8080'" $envfile.orig >> $envfile
    sed -e "/BEGIN DOMAIN DEF/,/END DOMAIN DEF/cconst domain = 'THEDOMAINLITERAL'" $envfile.orig >> $envfile

    # Uncomment when using SSL
    #sed -i "s/http:/https:/" $envfile

    echo "Original $envfile:"
    cat $envfile.orig

    echo -e "\nModified $envfile:"
    cat $envfile
    cp $envfile $envfile.mod
done;

echo

# Clobber any .env file that's there:
echo -e "# Generated by package-for-ecs $(date)\n" > .env

echo "Adding IMAGE_REPO to .env file..."
cat <<EOF >> .env
IMAGE_REPO=$IMAGE_REPO
EOF

echo "git commit hash is $GIT_COMMIT"
commitfiledir=dist/tcp-angular/assets/img
mkdir -p $commitfiledir
git log -1 > $commitfiledir/commit

echo "Building the $IMAGE_REPO Docker image..."
#npm ci
npm install
npm run docker:build
# package.json -> config.imageRepo has the name of the image repo npm built
docker tag $IMAGE_REPO $IMAGE_REPO:$GIT_COMMIT
# deploy script will look for $IMAGE_REPO:$GIT_COMMIT

echo "Checking for the Docker image..."
docker image ls | grep $IMAGE_REPO

date
