#!/bin/bash

# Create the Docker image for the service.
# All actions are local to the VM; does not use aws or ecs-cli.
# Should be run before deploy-to-ecs is run.
# Assumes the environemnt variable GIT_COMMIT is set (typically by Jenkins).
# Assumes the directory for the service exists in this directory,
# its name matches "*-ecs", and it is the only directory that matches.

# Fail on any error; unset variables are errors; show commands before executing:
set -eux
PROJECT="$1"
ENV="$2"
aws_region="$3"

GIT_COMMIT=${GIT_COMMIT:-unknown}

ECS_DIR=$(find . -maxdepth 1 -type d -name "*-ecs")

# TODO: see if logging anything from this script would be helpful

# TODO: make sure we're in the correct (root) directory
# Can just check for Dockerfile, and cd .. if not there

date

echo "Running in $PWD"
echo "Project = $PROJECT"
echo "Target Environment = $ENV"

docker --version

# Get the name ("repository" in Docker lingo) of the image from the doacker-compose.yml file:
grep "image: .*amazonaws.com/" $ECS_DIR/docker-compose.yml
IMAGE_REPO=$(grep "image: .*amazonaws.com/" $ECS_DIR/docker-compose.yml | sed "s/^[^\/]*\///")
echo "Image repository from $ECS_DIR/docker-compose.yml is $IMAGE_REPO"
if [[ "$IMAGE_REPO" = "" ]] ; then
    echo "ERROR: missing or empty image repository in $ECS_DIR/docker-compose.yml .  Quitting...."
    exit 2;
fi

# Find out what the external FQDN of the Application Load Balancer (ALB) is;
# change the domain line in ../src/environments/environment.prod.ts to
# use that instead of localhost; e.g.:
# const domain = 'tcp-testing-3-dev-cluster-alb-877192071.us-east-1.elb.amazonaws.com:8080'

alb=$(aws ssm get-parameter --region $aws_region --name "/$PROJECT/$ENV/alb/endpoint" --query "Parameter.Value" --out text)
echo "ALB FQDN is $alb"

# relative to project root:
for envfile in src/environments/environment.ts src/environments/environment.prod.ts ; do
    # If we rerun this, we want to start from the original file, not the modified version:
    if [[ ! -f $envfile.orig ]]; then
	mv $envfile $envfile.orig
    else
	rm $envfile
    fi
    # The const domain setting can span multiple lines, so we have to do this song and dance:
    touch $envfile
    echo -e "// Generated by deploy-to-ecs $(date)\n" >> $envfile
    # Replace everything between the BEGIN and END lines (inclusive) with const domain=...:
    sed -e "/BEGIN DOMAIN DEF/,/END DOMAIN DEF/cconst domain = '$alb:8080'" $envfile.orig >> $envfile

    echo "Original $envfile:"
    cat $envfile.orig

    echo -e "\nModified $envfile:"
    cat $envfile
done;

echo

echo "Generating .env file for ECS deployment..."
echo -n "" > $ECS_DIR/.env
cp -p .env $ECS_DIR/ ||:
# Note: do NOT use double-quotes around the values; bash isn't interpreting .env: ecs-cli compose is, and it does not drop quotes.
cat >> $ECS_DIR/.env <<EOF
AWS_REGION=${aws_region}
EOF

echo ".env file for ECS deployment:"
cat $ECS_DIR/.env
echo "--------"

echo

echo "git commit hash is $GIT_COMMIT"
mkdir -p src/assets/img
git log -1 > src/assets/img/commit

echo "Building the Docker image...."
npm run docker:build
# package.json -> config.imageRepo has the name of the image repo npm built
docker tag $IMAGE_REPO $IMAGE_REPO:$GIT_COMMIT
# TODO: should we even be tagging it "latest" yet?
# docker tag $IMAGE_REPO:$GIT_COMMIT $IMAGE_REPO:latest
# deploy script will look for $IMAGE_REPO:$GIT_COMMIT

echo "Checking for the Docker image..."
docker image ls | grep $IMAGE_REPO

date
